---
layout: single
title: "백준 12789번 문제풀이함수"
---

# 백준 12789번: 도키도키 간식드리미 (with python)
이번에는 백준 알고리즘 문제를 풀었는데 비교할게 많아 생각보다 오래 걸렸다   
Click [https://www.acmicpc.net/problem/12789](https://www.acmicpc.net/problem/12789)   
![image description](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/12789/1.png)

인하대학교 학생회에서는 중간, 기말고사 때마다 시험 공부에 지친 학우들을 위해 간식을 나눠주는 간식 드리미 행사를 실시한다. 승환이는 시험 기간이 될 때마다 간식을 받을 생각에 두근두근 설레서 시험 공부에 집중을 못 한다. 이번 중간고사에서도 역시 승환이는 설레는 가슴을 안고 간식을 받기 위해 미리 공지된 장소에 시간 맞춰 도착했다. 그런데 이게 무슨 날벼락인가! 그 곳에는 이미 모든 학생들이 모여있었고, 승환이는 마지막 번호표를 받게 되었다. 설상가상으로 몇몇 양심에 털이 난 학생들이 새치기를 거듭한 끝에 대기열의 순서마저 엉망이 되고 말았다. 간식을 나눠주고 있던 인규는 학우들의 터져 나오는 불만에 번호표 순서로만 간식을 줄 수 있다고 말했다. 

그제야 학생들이 순서대로 줄을 서려고 했지만 공간이 너무 협소해서 마음대로 이동할 수 없었다. 다행히도 대기열의 왼쪽에는 1열로 설 수 있는 공간이 존재하여 이 공간을 잘 이용하면 모두가 순서대로 간식을 받을 수 있을지도 모른다. 자칫 간식을 못 받게 될지도 모른다는 위기감을 느낀 승환이는 자신의 컴퓨터 알고리즘적 지식을 활용해 과연 모든 사람들이 순서대로 간식을 받을 수 있는지 확인하는 프로그램을 만들기로 했다. 만약 불가능 하다면 승환이는 이번 중간고사를 망치게 될 것 이고 가능하다면 힘을 얻어 중간고사를 잘 볼 수 있을지도 모른다.

사람들은 현재 1열로 줄을 서있고, 맨 앞의 사람만 이동이 가능하다. 인규는 번호표 순서대로만 통과할 수 있는 라인을 만들어 두었다. 이 라인과 대기열의 맨 앞 사람 사이에는 한 사람씩 1열이 들어갈 수 있는 공간이 있다. 현재 대기열의 사람들은 이 공간으로 올 수 있지만 반대는 불가능하다. 승환이를 도와 프로그램을 완성하라.

현재 간식 배부 공간을 그림으로 나타내면 다음과 같다.

### deque 함수
- deque는 양 끝에서의 요소 추가 및 제거를 O(1) 시간 복잡도로 처리할 수 있습니다. 반면, 일반 리스트는 끝에서의 요소 추가는 빠르지만, 시작 부분에 요소를 추가하거나 제거할 때는 O(n) 시간 복잡도가 필요하다.   
그래서 리스트의 양쪽 끝 어느 곳에서나 요소를 추가하거나 제거할 수 있는 deque함수를 사용하였다. 

### 사용 예제


```python
from collections import deque

dq = deque([1, 2, 3, 4, 5])

dq.append(6)  # [1, 2, 3, 4, 5, 6]
dq.appendleft(0)  # [0, 1, 2, 3, 4, 5, 6]
dq.pop()  # [0, 1, 2, 3, 4, 5]
dq.popleft()  # [1, 2, 3, 4, 5]

print(dq)  # 출력: deque([1, 2, 3, 4, 5])

```

    deque([1, 2, 3, 4, 5])
    

## 전체코드


```python
import sys
from collections import deque
input = sys.stdin.readline

n = int(input())
arr = deque(map(int, input().split()))
stack = deque()
cnt = 1
result = []
while len(result) != n:
    if len(arr) != 0:
        if arr[0] == cnt:
            order = arr.popleft()
            result.append(order)
            cnt += 1
        else:
            if len(result) == 0:
                num = arr.popleft()
                stack.append(num)
            else:
                if len(stack) > 0 and stack[-1] == cnt:  # 스택이 비어 있지 않은지 확인
                    order = stack.pop()
                    result.append(order)
                    cnt += 1
                else:
                    num = arr.popleft()
                    if len(stack) > 0 and stack[-1] < num:  # 스택이 비어 있지 않은지 확인
                        break
                    else:
                        stack.append(num)
    else:
        if len(stack) != 0:  # 스택이 비어 있지 않은지 확인
            num = stack.pop()
            if num != cnt:
                break
            else:
                result.append(num)
                cnt += 1

print("Nice" if len(result) == n else "Sad")

```


    ---------------------------------------------------------------------------

    ValueError                                Traceback (most recent call last)

    Cell In[7], line 5
          2 from collections import deque
          3 input = sys.stdin.readline
    ----> 5 n = int(input())
          6 arr = deque(map(int, input().split()))
          7 stack = deque()
    

    ValueError: invalid literal for int() with base 10: ''


## 세부적인 코드
먼저 아랫 코드는 처음 입력받은 순서가 뒤죽박죽인 배열에서 순서를 배열하기 위해 짠 코드이다.      
보이는 것과 같이 일일히 비교를 하면서 차례대로 들어가게 하였다


```python
while len(result) != n:
    if len(arr) != 0:
        if arr[0] == cnt:
            order = arr.popleft()
            result.append(order)
            cnt += 1
        else:
            if len(result) == 0:
                num = arr.popleft()
                stack.append(num)
            else:
                if len(stack) > 0 and stack[-1] == cnt:
                    order = stack.pop()
                    result.append(order)
                    cnt += 1
                else:
                    num = arr.popleft()
                    if len(stack) > 0 and stack[-1] < num:
                        break
                    else:
                        stack.append(num)
```


    ---------------------------------------------------------------------------

    NameError                                 Traceback (most recent call last)

    Cell In[6], line 1
    ----> 1 while len(result) != n:
          2     if len(arr) != 0:
          3         if arr[0] == cnt:
    

    NameError: name 'result' is not defined


코드를 구현하면서 문제가 몇몇 발생했는데 가장 큰 문제는 index오류였다.   
- 스택이 비어있는 상황에서 접근:
  스택이 비어 있는 경우 `stack[-1]`을 참조하려 하면 인덱스 에러가 발생하였다. 이걸 수정하기 위해 `len(stack) > 0`을 써줬다.

#### 결과:
메모리: 34060KB 시간: 60ms   

다음은 다른 사람의 숏코딩 코드이다. 이 코드를 많이 반성하게 됐다...   


```python
import sys
input = sys.stdin.readline

N = int(input())
people = list(map(int, input().split()))
stack = []
num = 1

for i in people:
    if i == num:
        num += 1
    else:
        stack.append(i)
    
    while stack and stack[-1] == num:
        stack.pop()
        num += 1

if not stack:
    print("Nice")
else:
    print("Sad")

```


    ---------------------------------------------------------------------------

    ValueError                                Traceback (most recent call last)

    Cell In[8], line 4
          1 import sys
          2 input = sys.stdin.readline
    ----> 4 N = int(input())
          5 people = list(map(int, input().split()))
          6 stack = []
    

    ValueError: invalid literal for int() with base 10: ''



```python

```
